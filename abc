Sure! Below is the complete and corrected code for both Angular (frontend) and Spring Boot (backend) to make edit and delete functionality work properly with your current setup.


---

‚úÖ Angular (Frontend)

exchange-rates.component.ts

import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-exchange-rates',
  templateUrl: './exchange-rates.component.html',
  styleUrls: ['./exchange-rates.component.css']
})
export class ExchangeRatesComponent implements OnInit {
  rates: ExchangeRate[] = [];
  newRate: ExchangeRate = { fromCurr: '', toCurr: '', rate: 0, lastMod: '' };
  editingRate: ExchangeRate | null = null;
  apiUrl = 'http://localhost:8080/api/exchange-rates';

  constructor(private http: HttpClient) {}

  ngOnInit(): void {
    this.fetchRates();
  }

  fetchRates(): void {
    this.http.get<ExchangeRate[]>(this.apiUrl).subscribe(data => {
      this.rates = data;
    });
  }

  save(): void {
    const payload = this.editingRate ? this.editingRate : this.newRate;
    const request = this.editingRate
      ? this.http.put(`${this.apiUrl}/${payload.fromCurr}`, payload)
      : this.http.post(this.apiUrl, payload);

    request.subscribe(() => {
      this.resetForm();
      this.fetchRates();
    });
  }

  edit(rate: ExchangeRate): void {
    this.editingRate = { ...rate };
  }

  delete(rate: ExchangeRate): void {
    this.http.delete(`${this.apiUrl}/${rate.fromCurr}`)
      .subscribe(() => this.fetchRates());
  }

  resetForm(): void {
    this.newRate = { fromCurr: '', toCurr: '', rate: 0, lastMod: '' };
    this.editingRate = null;
  }
}

interface ExchangeRate {
  fromCurr: string;
  toCurr: string;
  rate: number;
  lastMod: string;
}


---

‚úÖ Spring Boot (Backend)

ExchangeRateController.java

package com.example.recon_connect.controller;

import com.example.recon_connect.entity.ExchangeRate;
import com.example.recon_connect.repository.ExchangeRateRepository;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/exchange-rates")
@CrossOrigin(origins = "*")
public class ExchangeRateController {

    private final ExchangeRateRepository repository;

    public ExchangeRateController(ExchangeRateRepository repository) {
        this.repository = repository;
    }

    @GetMapping
    public List<ExchangeRate> getAll() {
        return repository.findAll();
    }

    @PostMapping
    public ExchangeRate add(@RequestBody ExchangeRate rate) {
        return repository.save(rate);
    }

    @PutMapping("/{fromCurr}")
    public ExchangeRate update(@PathVariable String fromCurr, @RequestBody ExchangeRate rate) {
        Optional<ExchangeRate> existing = repository.findById(fromCurr);
        if (existing.isPresent()) {
            ExchangeRate existingRate = existing.get();
            existingRate.setToCurr(rate.getToCurr());
            existingRate.setRate(rate.getRate());
            existingRate.setLastMod(rate.getLastMod());
            return repository.save(existingRate);
        } else {
            return repository.save(rate);
        }
    }

    @DeleteMapping("/{fromCurr}")
    public void delete(@PathVariable String fromCurr) {
        repository.deleteById(fromCurr);
    }
}


---

üîÅ Summary

Functionality	Angular	Spring Boot

Edit	PUT /{fromCurr}	Updates existing exchange rate
Delete	DELETE /{fromCurr}	Deletes by primary key fromCurr
Add	POST	Adds a new entry
Fetch	GET	Gets all records



---

If you're using a composite primary key (fromCurr + toCurr), let me know ‚Äî the solution will require @EmbeddedId changes in the backend.

Would you like me to help wire this to your exchange-rates.component.html template too?

