Based on your images and uploaded reference files, you're working on a Spring Boot backend for managing exchange rates. I’ll now provide a complete backend implementation for CRUD operations on the ExchangeRates_Rachana Oracle table with the structure:

FROMCURR (VARCHAR2)

TOCURR (VARCHAR2)

RATE (NUMBER)

LASTMOD (DATE)



---

✅ Folder Structure (Package: com.recon_connect)

src/
└── main/
    └── java/
        └── com/
            └── recon_connect/
                ├── controller/
                │   └── ExchangeRateController.java
                ├── entity/
                │   └── ExchangeRate.java
                ├── repository/
                │   └── ExchangeRateRepository.java
                ├── config/
                │   └── CorsConfig.java
                └── ReconApplication.java


---

1. ExchangeRate.java (Entity)

package com.recon_connect.entity;

import jakarta.persistence.*;
import java.util.Date;

@Entity
@Table(name = "ExchangeRates_Rachana")
public class ExchangeRate {

    @Id
    @Column(name = "FROMCURR")
    private String fromCurr;

    @Column(name = "TOCURR")
    private String toCurr;

    @Column(name = "RATE")
    private Double rate;

    @Column(name = "LASTMOD")
    @Temporal(TemporalType.DATE)
    private Date lastMod;

    // Getters and Setters
    public String getFromCurr() {
        return fromCurr;
    }

    public void setFromCurr(String fromCurr) {
        this.fromCurr = fromCurr;
    }

    public String getToCurr() {
        return toCurr;
    }

    public void setToCurr(String toCurr) {
        this.toCurr = toCurr;
    }

    public Double getRate() {
        return rate;
    }

    public void setRate(Double rate) {
        this.rate = rate;
    }

    public Date getLastMod() {
        return lastMod;
    }

    public void setLastMod(Date lastMod) {
        this.lastMod = lastMod;
    }
}


---

2. ExchangeRateRepository.java

package com.recon_connect.repository;

import com.recon_connect.entity.ExchangeRate;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ExchangeRateRepository extends JpaRepository<ExchangeRate, String> {
}


---

3. ExchangeRateController.java

package com.recon_connect.controller;

import com.recon_connect.entity.ExchangeRate;
import com.recon_connect.repository.ExchangeRateRepository;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/exchange-rates")
@CrossOrigin(origins = "*")
public class ExchangeRateController {

    private final ExchangeRateRepository repository;

    public ExchangeRateController(ExchangeRateRepository repository) {
        this.repository = repository;
    }

    @GetMapping
    public List<ExchangeRate> getAll() {
        return repository.findAll();
    }

    @PostMapping
    public ExchangeRate add(@RequestBody ExchangeRate rate) {
        return repository.save(rate);
    }

    @PutMapping("/{fromCurr}")
    public ExchangeRate update(@PathVariable String fromCurr, @RequestBody ExchangeRate rate) {
        Optional<ExchangeRate> existing = repository.findById(fromCurr);
        if (existing.isPresent()) {
            ExchangeRate existingRate = existing.get();
            existingRate.setToCurr(rate.getToCurr());
            existingRate.setRate(rate.getRate());
            existingRate.setLastMod(rate.getLastMod());
            return repository.save(existingRate);
        } else {
            return repository.save(rate); // Or throw error if you want strict update
        }
    }

    @DeleteMapping("/{fromCurr}")
    public void delete(@PathVariable String fromCurr) {
        repository.deleteById(fromCurr);
    }
}


---

4. CorsConfig.java (Optional CORS config)

package com.recon_connect.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class CorsConfig {
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                        .allowedOrigins("*")
                        .allowedMethods("*");
            }
        };
    }
}


---

5. ReconApplication.java (Main class)

package com.recon_connect;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ReconApplication {

    public static void main(String[] args) {
        SpringApplication.run(ReconApplication.class, args);
    }
}


---

✅ application.properties (Oracle DB connection)

spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xe
spring.datasource.username=your_oracle_username
spring.datasource.password=your_oracle_password
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.Oracle12cDialect


---

Would you like the corresponding Angular 17 code that interacts with this backend and reflects changes on the UI as discussed earlier?

