Thanks for pointing that out. The error Expected 0 arguments but found 2 in the line:

Optional<ExchangeRate> optionalRate = repository.findById(new ExchangeRate(fromCurr, toCurr));

‚Ä¶is because you're trying to call findById() with an ExchangeRate object instead of the correct composite key type.


---

üîß Fixing the Core Issue

Your ExchangeRate table uses a composite primary key: fromCurr and toCurr. For Spring Data JPA to work correctly with findById(), you must provide a key object ‚Äî either via:

Option 1: Create a key class (Recommended by Spring)

If you don‚Äôt want this, skip to Option 2 (but that uses a workaround).


---

‚úÖ ‚úÖ Option 1: Proper Way ‚Äî Use @IdClass

1. Create the key class ExchangeRateKey.java:

import java.io.Serializable;
import java.util.Objects;

public class ExchangeRateKey implements Serializable {
    private String fromCurr;
    private String toCurr;

    // Constructors
    public ExchangeRateKey() {}
    public ExchangeRateKey(String fromCurr, String toCurr) {
        this.fromCurr = fromCurr;
        this.toCurr = toCurr;
    }

    // equals and hashCode
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ExchangeRateKey)) return false;
        ExchangeRateKey that = (ExchangeRateKey) o;
        return fromCurr.equals(that.fromCurr) && toCurr.equals(that.toCurr);
    }

    @Override
    public int hashCode() {
        return Objects.hash(fromCurr, toCurr);
    }
}

2. Update your ExchangeRate entity:

@Entity
@IdClass(ExchangeRateKey.class)
@Table(name = "ExchangeRates_Rachana")
public class ExchangeRate {

    @Id
    private String fromCurr;

    @Id
    private String toCurr;

    private Double rate;

    @Temporal(TemporalType.DATE)
    private Date lastMod;

    // Getters/Setters
}


---

‚úÖ 3. Update your controller method:

@PutMapping("/exchange-rates/{fromCurr}/{toCurr}")
public ResponseEntity<ExchangeRate> updateExchangeRate(
        @PathVariable String fromCurr,
        @PathVariable String toCurr,
        @RequestBody ExchangeRate updatedRate) {

    ExchangeRateKey key = new ExchangeRateKey(fromCurr, toCurr);
    Optional<ExchangeRate> optionalRate = repository.findById(key);

    if (optionalRate.isPresent()) {
        // Handle PK change
        if (!fromCurr.equals(updatedRate.getFromCurr()) || !toCurr.equals(updatedRate.getToCurr())) {
            repository.deleteById(key); // remove old
        }

        ExchangeRate saved = repository.save(updatedRate); // insert new
        return ResponseEntity.ok(saved);
    } else {
        return ResponseEntity.notFound().build();
    }
}


---

‚ùå Option 2: Workaround (Not Recommended)

Using .findByFromCurrAndToCurr(...) in your repository:

Optional<ExchangeRate> optionalRate = repository.findByFromCurrAndToCurr(fromCurr, toCurr);

You‚Äôd then need to define this in your repository interface:

Optional<ExchangeRate> findByFromCurrAndToCurr(String fromCurr, String toCurr);

But this approach won‚Äôt support deleteById or save properly in some cases unless you do extra mapping.


---

‚úÖ Best Option Summary

‚úÖ Add ExchangeRateKey.java
‚úÖ Use @IdClass(ExchangeRateKey.class)
‚úÖ Pass the key object to findById() and deleteById()


---

Would you like me to give you the full final code with all three files updated (Entity, Key, Controller)?

