Thanks for the clarification and the image. Based on your requirements:

âœ… You want to edit all fields, including fromCurr (which is part of the primary key).

âœ… You do not want to create a new ExchangeRateKey class.

âœ… You want edits to reflect correctly in the Angular table.

ðŸ”§ Your current controller uses only fromCurr in the @PutMapping, which wonâ€™t work correctly because your table has a composite primary key: fromCurr and toCurr.



---

âœ… Corrected Spring Boot Controller Code

Update your @PutMapping like this to work without creating a new class:

@PutMapping("/exchange-rates/{fromCurr}/{toCurr}")
public ResponseEntity<ExchangeRate> updateExchangeRate(
        @PathVariable String fromCurr,
        @PathVariable String toCurr,
        @RequestBody ExchangeRate updatedRate) {

    Optional<ExchangeRate> optionalRate = repository.findById(new ExchangeRate(fromCurr, toCurr));
    if (optionalRate.isPresent()) {
        ExchangeRate existingRate = optionalRate.get();

        // If primary key changed, delete the old and insert new
        if (!fromCurr.equals(updatedRate.getFromCurr()) || !toCurr.equals(updatedRate.getToCurr())) {
            repository.deleteById(new ExchangeRate(fromCurr, toCurr));
        }

        // Save the new/updated entity
        repository.save(updatedRate);
        return ResponseEntity.ok(updatedRate);
    } else {
        return ResponseEntity.notFound().build();
    }
}


---

ðŸ”§ Entity Fix (if you're not using @IdClass)

Make sure your ExchangeRate entity uses this:

@Entity
@Table(name = "ExchangeRates_Rachana")
@IdClass(ExchangeRate.class) // optional if you're not using @Embeddable or another class
public class ExchangeRate {

    @Id
    @Column(name = "FROMCURR")
    private String fromCurr;

    @Id
    @Column(name = "TOCURR")
    private String toCurr;

    @Column(name = "RATE")
    private double rate;

    @Column(name = "LASTMOD")
    @Temporal(TemporalType.DATE)
    private Date lastMod;

    // Constructors, Getters, Setters
}

But if this doesn't work, Spring requires a class or @EmbeddedId to handle composite keys properly.

So if you want a guaranteed solution without extra logic hacks, you'd still be better off making a lightweight ExchangeRateKey class as described earlier.


---

âœ… Final Notes

Your Angular UI should send all fields (including the old and new fromCurr, toCurr) when editing.

You may need to temporarily store the original PKs if you're editing them in the UI.


Would you like help modifying the Angular part to send both original and edited keys?

