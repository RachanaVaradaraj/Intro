Here is the complete Spring Boot backend code to support the Angular frontend with the following features:

✅ CRUD for exchange rates
✅ Endpoints to fetch distinct fromCurr and toCurr values
✅ Connected to Oracle table ExchangeRates_Rachana


---

✅ 1. ExchangeRate.java (Entity)

package com.recon_connect.entity;

import jakarta.persistence.*;
import java.util.Date;

@Entity
@Table(name = "ExchangeRates_Rachana")
@IdClass(ExchangeRateId.class)
public class ExchangeRate {
    
    @Id
    @Column(name = "FROMCURR")
    private String fromCurr;

    @Id
    @Column(name = "TOCURR")
    private String toCurr;

    @Column(name = "RATE")
    private Double rate;

    @Column(name = "LASTMOD")
    @Temporal(TemporalType.DATE)
    private Date lastMod;

    // Getters and Setters
    public String getFromCurr() { return fromCurr; }
    public void setFromCurr(String fromCurr) { this.fromCurr = fromCurr; }

    public String getToCurr() { return toCurr; }
    public void setToCurr(String toCurr) { this.toCurr = toCurr; }

    public Double getRate() { return rate; }
    public void setRate(Double rate) { this.rate = rate; }

    public Date getLastMod() { return lastMod; }
    public void setLastMod(Date lastMod) { this.lastMod = lastMod; }
}


---

✅ 2. ExchangeRateId.java (Composite Key)

package com.recon_connect.entity;

import java.io.Serializable;
import java.util.Objects;

public class ExchangeRateId implements Serializable {
    private String fromCurr;
    private String toCurr;

    public ExchangeRateId() {}

    public ExchangeRateId(String fromCurr, String toCurr) {
        this.fromCurr = fromCurr;
        this.toCurr = toCurr;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ExchangeRateId)) return false;
        ExchangeRateId that = (ExchangeRateId) o;
        return Objects.equals(fromCurr, that.fromCurr) && Objects.equals(toCurr, that.toCurr);
    }

    @Override
    public int hashCode() {
        return Objects.hash(fromCurr, toCurr);
    }
}


---

✅ 3. ExchangeRateRepository.java

package com.recon_connect.repository;

import com.recon_connect.entity.ExchangeRate;
import com.recon_connect.entity.ExchangeRateId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import java.util.List;

public interface ExchangeRateRepository extends JpaRepository<ExchangeRate, ExchangeRateId> {
    
    @Query("SELECT DISTINCT e.fromCurr FROM ExchangeRate e")
    List<String> findDistinctFromCurr();

    @Query("SELECT DISTINCT e.toCurr FROM ExchangeRate e")
    List<String> findDistinctToCurr();
}


---

✅ 4. ExchangeRateController.java

package com.recon_connect.controller;

import com.recon_connect.entity.ExchangeRate;
import com.recon_connect.entity.ExchangeRateId;
import com.recon_connect.repository.ExchangeRateRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/exchange-rates")
@CrossOrigin(origins = "http://localhost:4200")
public class ExchangeRateController {

    @Autowired
    private ExchangeRateRepository repository;

    @GetMapping
    public List<ExchangeRate> getAllRates() {
        return repository.findAll();
    }

    @GetMapping("/fromCurrs")
    public List<String> getFromCurrs() {
        return repository.findDistinctFromCurr();
    }

    @GetMapping("/toCurrs")
    public List<String> getToCurrs() {
        return repository.findDistinctToCurr();
    }

    @PostMapping
    public ExchangeRate addRate(@RequestBody ExchangeRate rate) {
        return repository.save(rate);
    }

    @PutMapping("/{fromCurr}/{toCurr}")
    public ExchangeRate updateRate(@PathVariable String fromCurr, @PathVariable String toCurr,
                                   @RequestBody ExchangeRate updatedRate) {
        ExchangeRateId id = new ExchangeRateId(fromCurr, toCurr);
        Optional<ExchangeRate> optional = repository.findById(id);

        if (optional.isPresent()) {
            ExchangeRate existing = optional.get();
            existing.setRate(updatedRate.getRate());
            existing.setLastMod(updatedRate.getLastMod());
            existing.setFromCurr(updatedRate.getFromCurr());
            existing.setToCurr(updatedRate.getToCurr());
            return repository.save(existing);
        } else {
            throw new RuntimeException("Rate not found");
        }
    }

    @DeleteMapping("/{fromCurr}/{toCurr}")
    public void deleteRate(@PathVariable String fromCurr, @PathVariable String toCurr) {
        ExchangeRateId id = new ExchangeRateId(fromCurr, toCurr);
        repository.deleteById(id);
    }
}


---

✅ 5. ReconApplication.java (Main class)

package com.recon_connect;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ReconApplication {
    public static void main(String[] args) {
        SpringApplication.run(ReconApplication.class, args);
    }
}


---

✅ 6. application.properties

spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xe
spring.datasource.username=your_db_username
spring.datasource.password=your_db_password
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=true
spring.jpa.database-platform=org.hibernate.dialect.Oracle12cDialect


---

Let me know if you want:

SQL to create the ExchangeRates_Rachana table

A sample dataset

Help setting up CORS for production


Ready to continue when you are!

